#include "Common.dsf"
#include "DeferredShadingCommon.dsf"

struct SceneVSInput
{
    float3 Position  : POSITION;
    float3 Normal : NORMAL;
};

//--------------------------------------------------------------------------------------
struct SceneVSOutput
{
    float4 Position : SV_POSITION;
    float3 NormalWorld: TEXCOORD0; 
	float3 PositionWorld: TEXCOORD1;
};

SceneVSOutput RenderSceneVS( SceneVSInput input )
{   
    SceneVSOutput output;
    output.Position = mul( float4(input.Position,1.0f),WorldTransform);
	output.PositionWorld = output.Position.xyz;
    output.Position = mul( output.Position, CameraView );
    output.Position = mul( output.Position, CameraProjection );
    output.NormalWorld = mul(float4(input.Normal,1.0),WorldNormalTransform).xyz;
	
    return output;
}

/////////////////////////////////////////////////////////////////////////////
// Pixel shader
/////////////////////////////////////////////////////////////////////////////

struct ScenePSOutput
{
	float4 ColorShiness : SV_TARGET0;
	float4 Normal : SV_TARGET1;
	float4 SpecColor : SV_TARGET2;
};

ScenePSOutput PackGBuffer(float3 BaseColor, float3 Normal, float3 SpecColor, float SpecPower)
{
	ScenePSOutput Out;
 
	// Pack all the data into the GBuffer structure
	Out.ColorShiness = float4(BaseColor.rgb, SpecPower);
	Out.Normal = float4(Normal * 0.5 + 0.5, 0.0);
	Out.SpecColor = float4(SpecColor,0.0);

	return Out;
}

ScenePSOutput RenderScenePS( SceneVSOutput In )
{ 
    // Lookup mesh texture and modulate it with diffuse
   // float3 DiffuseColor = DiffuseTexture.Sample( LinearSampler, In.UV );
	//DiffuseColor *= DiffuseColor;

	return PackGBuffer(DiffuseColor, normalize(In.NormalWorld), SpecularColor, Shininess);
}
 
GBufferData UnpackGBuffer(int2 location)
{
	GBufferData Out;
	int3 location3 = int3(location, 0);

	float depth = GBufferDepthTexture.Load(location3).x;
	Out.LinearDepth = ConvertZToLinearDepth(depth);
	float4 baseColorSpecInt = GBufferColorSpecIntTexture.Load(location3);
	Out.Color = baseColorSpecInt.xyz;
	Out.Shiness = baseColorSpecInt.w;
	Out.Normal = GBufferNormalTexture.Load(location3).xyz;
	Out.Normal = normalize(Out.Normal * 2.0 - 1.0);
	Out.SpecularColor = GBufferSpecPowTexture.Load(location3).xyz;

	return Out;
}

void MaterialFromGBuffer(GBufferData gbd, inout Material mat)
{
	mat.Normal = gbd.Normal;
	mat.DiffuseColor.xyz = gbd.Color;
	mat.SpecularColor = gbd.SpecularColor;
	mat.Shininess = gbd.Shiness;
}

/////////////////////////Lighting///////////////////////////////////////////////

struct LightVSOutput
{
	float4 Position : SV_Position; // vertex position 
	float2 ScreenPos: TEXCOORD0;
};

LightVSOutput LightingVS( uint VertexID : SV_VertexID )
{
	LightVSOutput Output;

	Output.Position = ScreenSpacePos[VertexID];
	Output.ScreenPos = Output.Position.xy;

	return Output;    
}

float4 LightingPS(LightVSOutput In) : SV_TARGET
{
	// Unpack the GBuffer
	GBufferData gbd = UnpackGBuffer(In.Position.xy);
	
	// Convert the data into the material structure
	Material mat;
	MaterialFromGBuffer(gbd, mat);

	// Reconstruct the world position
	float3 position = CalcWorldPos(In.ScreenPos, gbd.LinearDepth);

	// Calculate the ambient color
	float3 finalColor = CalculateAmbient(mat.Normal, mat.DiffuseColor);

	// Calculate the directional light
	finalColor += CalculateDirectionLight(position, mat);

	// Return the final color
	return float4(finalColor, 1.0);
}
