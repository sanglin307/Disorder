#include "Common.dsf"

struct VS_INPUT
{
    float3 Position  : POSITION;
    float3 Normal : NORMAL;
};

//--------------------------------------------------------------------------------------
struct VS_OUTPUT
{
    float4 Position : SV_POSITION;
    float3 NormalWorld: TEXCOORD0; 
	float3 PositionWorld: TEXCOORD1;
};
 
//--------------------------------------------------------------------------------------
// Vertex Shader
//--------------------------------------------------------------------------------------
VS_OUTPUT RenderSceneVS( VS_INPUT input )
{
    VS_OUTPUT output;
    output.Position = mul( float4(input.Position,1.0f),WorldTransform);
	output.PositionWorld = output.Position.xyz;
    output.Position = mul( output.Position, CameraView );
    output.Position = mul( output.Position, CameraProjection );
    output.NormalWorld = mul(float4(input.Normal,1.0),WorldNormalTransform).xyz;
	
    return output;
}

//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------


float3 CalculateDirectionLight(float3 position, Material material)
{
   //diffuse
   float3 lightColor = DirectionLightIntensity * DirectionLightColor.rgb;
   float NDotL = max(dot(DirectionLightDir, material.Normal),0);
   float3 finalColor = lightColor * NDotL * material.DiffuseColor;
   
   //specular
   float3 ToEye = normalize(CameraPosition - position);
   float3 reflectVector = reflect(-DirectionLightDir,material.Normal);
   float NDotH = max(dot(reflectVector, ToEye),0);
   finalColor += lightColor * saturate(pow(NDotH, material.Shininess)) * material.SpecularColor;
   
   return finalColor;
}


float4 DirectionalLightPS( VS_OUTPUT input ) : SV_Target
{
    Material mat = PrepareMaterial(input.NormalWorld,(float2)0);

	float3 finalColor = CalculateAmbient(mat.Normal,mat.DiffuseColor);

	finalColor += CalculateDirectionLight(input.PositionWorld,mat);

    return float4(finalColor,1.0f);
}

cbuffer ForwardFourLights : register( b1 )
{
	float4 ForwardLightPosX			: packoffset( c0 );
	float4 ForwardLightPosY			: packoffset( c1 );
	float4 ForwardLightPosZ			: packoffset( c2 );
	float4 ForwardLightDirX			: packoffset( c3 );
	float4 ForwardLightDirY			: packoffset( c4 );
	float4 ForwardLightDirZ			: packoffset( c5 );
	float4 ForwardLightRangeRcp		: packoffset( c6 );
	float4 ForwardSpotCosOuterCone		: packoffset( c7 );
	float4 ForwardSpotCosInnerConeRcp	: packoffset( c8 );
	float4 ForwardCapsuleLen			: packoffset( c9 );
	float4 ForwardLightColorR			: packoffset( c10 );
	float4 ForwardLightColorG			: packoffset( c11 );
	float4 ForwardLightColorB			: packoffset( c12 );
}

/////////////////////////////////////////////////////////////////////////////
// Pixel shaders
/////////////////////////////////////////////////////////////////////////////


float4 dot4x4(float4 aX, float4 aY, float4 aZ, float4 bX, float4 bY, float4 bZ)
{
	return aX * bX + aY * bY + aZ * bZ;
}

// Dot product between a four three component vectors and a single three component vector
float4 dot4x1(float4 aX, float4 aY, float4 aZ, float3 b)
{
	return aX * b.xxxx + aY * b.yyyy + aZ * b.zzzz;
}

// Four light calculation helper function
float3 CalcFourLights(float3 position, Material material)
{
	float3 ToEye = EyePosition.xyz - position;
   
	// Find the shortest distance between the pixel and capsules segment
	float4 ToCapsuleStartX = position.xxxx - LightPosX;
	float4 ToCapsuleStartY = position.yyyy - LightPosY;
	float4 ToCapsuleStartZ = position.zzzz - LightPosZ;
	float4 DistOnLine = dot4x4(ToCapsuleStartX, ToCapsuleStartY, ToCapsuleStartZ, LightDirX, LightDirY, LightDirZ);
	float4 CapsuleLenSafe = max(CapsuleLen, 1.e-6);
	DistOnLine = CapsuleLen * saturate(DistOnLine / CapsuleLenSafe);
	float4 PointOnLineX = LightPosX + LightDirX * DistOnLine;
	float4 PointOnLineY = LightPosY + LightDirY * DistOnLine;
	float4 PointOnLineZ = LightPosZ + LightDirZ * DistOnLine;
	float4 ToLightX = PointOnLineX - position.xxxx;
	float4 ToLightY = PointOnLineY - position.yyyy;
	float4 ToLightZ = PointOnLineZ - position.zzzz;
	float4 DistToLightSqr = dot4x4(ToLightX, ToLightY, ToLightZ, ToLightX, ToLightY, ToLightZ);
	float4 DistToLight = sqrt(DistToLightSqr);
   
	// Phong diffuse
	ToLightX /= DistToLight; // Normalize
	ToLightY /= DistToLight; // Normalize
	ToLightZ /= DistToLight; // Normalize
	float4 NDotL = saturate(dot4x1(ToLightX, ToLightY, ToLightZ, material.normal));
	//float3 finalColor = float3(dot(LightColorR, NDotL), dot(LightColorG, NDotL), dot(LightColorB, NDotL));
   
	// Blinn specular
	ToEye = normalize(ToEye);
	float4 HalfWayX = ToEye.xxxx + ToLightX;
	float4 HalfWayY = ToEye.yyyy + ToLightY;
	float4 HalfWayZ = ToEye.zzzz + ToLightZ;
	float4 HalfWaySize = sqrt(dot4x4(HalfWayX, HalfWayY, HalfWayZ, HalfWayX, HalfWayY, HalfWayZ));
	float4 NDotH = saturate(dot4x1(HalfWayX / HalfWaySize, HalfWayY / HalfWaySize, HalfWayZ / HalfWaySize, material.normal));
	float4 SpecValue = pow(NDotH, material.specExp.xxxx) * material.specIntensity;
	//finalColor += float3(dot(LightColorR, SpecValue), dot(LightColorG, SpecValue), dot(LightColorB, SpecValue));
   
	// Cone attenuation
	float4 cosAng = dot4x4(LightDirX, LightDirY, LightDirZ, ToLightX, ToLightY, ToLightZ);
	float4 conAtt = saturate((cosAng - SpotCosOuterCone) * SpotCosInnerConeRcp);
	conAtt *= conAtt;
   
	// Attenuation
	float4 DistToLightNorm = 1.0 - saturate(DistToLight * LightRangeRcp);
	float4 Attn = DistToLightNorm * DistToLightNorm;
	Attn *= conAtt; // Include the cone attenuation

	// Calculate the final color value
	float4 pixelIntensity = (NDotL + SpecValue) * Attn;
	float3 finalColor = float3(dot(LightColorR, pixelIntensity), dot(LightColorG, pixelIntensity), dot(LightColorB, pixelIntensity)); 
	finalColor *= material.diffuseColor;
   
	return finalColor;
}

float4 ForwardFourLightPS( VS_OUTPUT In ) : SV_TARGET0
{
	// Prepare the material structure
	Material material = PrepareMaterial(In.Normal, In.UV);

	// Calculate the spot light color
	float3 finalColor = CalcFourLights(In.WorldPos, material);

	// Return the final color
	return float4(finalColor, 1.0);
}